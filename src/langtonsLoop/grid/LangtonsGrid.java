package langtonsLoop.grid;
import javafx.animation.AnimationTimer;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;

import langtonsLoop.Runner;
import langtonsLoop.cell.Cell;

import java.util.*;
import java.util.concurrent.TimeUnit;

public class LangtonsGrid implements Runner {

    private final GridPane GRID;
    private  List<List<Cell>> cells = new ArrayList<>();
    private Map<String,Character> map;
    private final double CELL_SIZE;

    // Class Constructor
    public LangtonsGrid(GridPane grid, List<String> configList, List<String> list, double cellSize) {
        GRID = grid;
        CELL_SIZE = cellSize;
        createHashMap(list);

        initializeGrid(configList);
    }

    /**
     *
     * @param configList
     * This method is called inside the constructor
     * Size of row and column for initial gird are determined with configList
     * List of type Cell called rowCells is created by inner for loop.
     * The outer for loop helps to create list of rowCells of size equal to row.
     */
    private void initializeGrid(List<String> configList) {
        int columnSize = configList.get(0).length();
        int rowSize = configList.size();
        for ( int i = 0; i< rowSize; i++){
            List<Cell> rowCells = new ArrayList<>();
            for (int j =0; j<columnSize; j++){
                char c = configList.get(i).charAt(j);
                rowCells.add(Cell.fromChar(c));
            }
            cells.add(rowCells);
        }
    }

    /**
     *
     * @param list
     * The list of rule is used to determine the next state in langton`s loop.
     * To accommodate the rotational property of the neighbors, four possible combination strings
     *     are created because there are only four ways neighbors can align without breaking an order.
     * Each of the substrings are stored in the map with same value.
     * Te map generated has key of String type and value of character type.
     */
    private void createHashMap(List<String> list) {
        map = new HashMap<>();
        int size = list.size();
        for (int index = 0; index < size; index++){
            String ruleStr = list.get(index);
            int strSize = ruleStr.length();
            String subString1= ""+ruleStr.charAt(0)+ruleStr.charAt(1)+ruleStr.charAt(2)+ruleStr.charAt(3)+
                    ruleStr.charAt(4);
            String subString2 = ""+ruleStr.charAt(0)+ruleStr.charAt(2)+ruleStr.charAt(3)+ruleStr.charAt(4)+
                    ruleStr.charAt(1);
            String subString3= ""+ruleStr.charAt(0)+ruleStr.charAt(3)+ruleStr.charAt(4)+ruleStr.charAt(1)+
                    ruleStr.charAt(2);
            String subString4= ""+ruleStr.charAt(0)+ruleStr.charAt(4)+ruleStr.charAt(1)+ruleStr.charAt(2)+
                    ruleStr.charAt(3);

            map.put(subString1,ruleStr.charAt(strSize-1));
            map.put(subString2,ruleStr.charAt(strSize-1));
            map.put(subString3,ruleStr.charAt(strSize-1));
            map.put(subString4,ruleStr.charAt(strSize-1));


        }
    }

    // Provided with skeleton
    @Override
    public void run() {

        AnimationTimer timer = new AnimationTimer() {
            private long prevUpdate = 0;
            @Override
            public void handle(long now) {
                if (now - prevUpdate >= TimeUnit.SECONDS.toNanos(1)) {
                    nextGeneration();
                    prevUpdate = now;
                }
            }
        };
        timer.start();
    }

    private void nextGeneration() {
        evolve();
        show();
    }

    /**
     * In this method, the next state of the element being looked at is determined
     * Using two nested for loop, all the elements in the cells are accessed.
     * To implement wrap around property, modulus operator is used.
     * The string of key is generated by concatenating element being looked, north neighbor,
     *     east neighbor, south neighbor adn west neighbor in that order.
     * The next character value is determined by value of that key.
     * The next state Cell is created using fromChar() method and added to list of type Cell called newRowCells.
     * The newRowCells are then added to newCells which is List of List of Cells.
     * At termination, newCells is assigned to cells.
     */
    private void evolve() {
        int rowSize = cells.size();
        int columnSize = cells.get(0).size();
        List<List<Cell>> newCells = new ArrayList<>();
        for (int i = 0; i<rowSize; i++){
            List<Cell> newRowCells = new ArrayList<>();
            for (int j = 0; j<columnSize; j++){
                String me = cells.get(i).get(j).toString(); // Cell being observed
                String north = cells.get( (i+rowSize-1)%rowSize ).get(j).toString(); // North Neighbor
                String east =  cells.get(i).get( (j+1)%columnSize ).toString(); // East Neighbor
                String south = cells.get((i+1)%rowSize).get(j).toString(); //South neighbor
                String west = cells.get(i).get((j+columnSize-1)%columnSize).toString(); // West neighbor
                String key = me+north+east+south+west;

                Cell newMe = Cell.fromChar(map.get(key));
                //System.out.print(newMe);
                newRowCells.add(newMe);
            }
            //System.out.println();
            newCells.add(newRowCells);
        }
        cells = newCells;

    }

    /**
     * The show function from the Blinker class was used as a reference for this method.
     * The implementation is very similar.
     * Two nested for loops are used to access every elements in cells.
     * The color of that Cell is added to the GRID.
     */
    private void show() {
        GRID.getChildren().clear();
        int rowIndex = 0;
        int colIndex = 0;

        for (List<Cell> row : cells) {
            for (Cell cell : row) {
                Rectangle rect = new Rectangle(CELL_SIZE, CELL_SIZE, cell.getColor());
                GRID.add(rect,colIndex,rowIndex);
                colIndex++;
            }
            colIndex = 0;
            rowIndex++;
        }
    }
}
